// Code generated by turbopuffer-apigen. DO NOT EDIT.

package com.turbopuffer.models.namespaces

import com.fasterxml.jackson.annotation.JsonAutoDetect
import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility
import com.fasterxml.jackson.annotation.JsonFormat
import com.fasterxml.jackson.annotation.JsonIgnore
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.annotation.JsonPropertyOrder
import com.turbopuffer.core.JsonValue

sealed class AggregateBy() {
    companion object {
        @JvmStatic public fun count(attr: String): AggregateByCount = AggregateByCount.create(attr)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("f0", "attr")
class AggregateByCount private constructor(private val attr: String) : AggregateBy() {
    private val f0: String = "Count"

    companion object {
        @JvmSynthetic internal fun create(attr: String): AggregateByCount = AggregateByCount(attr)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class ContainsAllTokensArray
private constructor(private val attr: String, private val value: List<String>) : Filter() {
    private val f0: String = "ContainsAllTokens"

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: List<String>): ContainsAllTokensArray =
            ContainsAllTokensArray(attr, value)
    }
}

sealed class Filter() {
    companion object {
        @JvmStatic
        public fun eq(attr: String, value: JsonValue): FilterEq = FilterEq.create(attr, value)

        @JvmStatic
        public fun notEq(attr: String, value: JsonValue): FilterNotEq =
            FilterNotEq.create(attr, value)

        @JvmStatic
        public fun `in`(attr: String, value: JsonValue): FilterIn = FilterIn.create(attr, value)

        @JvmStatic
        public fun notIn(attr: String, value: JsonValue): FilterNotIn =
            FilterNotIn.create(attr, value)

        @JvmStatic
        public fun lt(attr: String, value: JsonValue): FilterLt = FilterLt.create(attr, value)

        @JvmStatic
        public fun lte(attr: String, value: JsonValue): FilterLte = FilterLte.create(attr, value)

        @JvmStatic
        public fun gt(attr: String, value: JsonValue): FilterGt = FilterGt.create(attr, value)

        @JvmStatic
        public fun gte(attr: String, value: JsonValue): FilterGte = FilterGte.create(attr, value)

        @JvmStatic
        public fun glob(attr: String, value: String): FilterGlob = FilterGlob.create(attr, value)

        @JvmStatic
        public fun notGlob(attr: String, value: String): FilterNotGlob =
            FilterNotGlob.create(attr, value)

        @JvmStatic
        public fun iGlob(attr: String, value: String): FilterIGlob = FilterIGlob.create(attr, value)

        @JvmStatic
        public fun notIGlob(attr: String, value: String): FilterNotIGlob =
            FilterNotIGlob.create(attr, value)

        @JvmStatic
        public fun containsAllTokens(attr: String, value: String): FilterContainsAllTokens =
            FilterContainsAllTokens.create(attr, value)

        @JvmStatic
        public fun containsAllTokensArray(
            attr: String,
            value: List<String>,
        ): ContainsAllTokensArray = ContainsAllTokensArray.create(attr, value)

        @JvmStatic public fun not(filter: Filter): FilterNot = FilterNot.create(filter)

        @JvmStatic public fun and(filters: List<Filter>): FilterAnd = FilterAnd.create(filters)

        @JvmStatic public fun or(filters: List<Filter>): FilterOr = FilterOr.create(filters)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("f0", "filters")
class FilterAnd private constructor(private val filters: List<Filter>) : Filter() {
    private val f0: String = "And"

    companion object {
        @JvmSynthetic internal fun create(filters: List<Filter>): FilterAnd = FilterAnd(filters)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterContainsAllTokens
private constructor(private val attr: String, private val value: String) : Filter() {
    private val f0: String = "ContainsAllTokens"

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: String): FilterContainsAllTokens =
            FilterContainsAllTokens(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterEq private constructor(private val attr: String, private val value: JsonValue) :
    Filter() {
    private val f0: String = "Eq"

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: JsonValue): FilterEq = FilterEq(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterGlob private constructor(private val attr: String, private val value: String) :
    Filter() {
    private val f0: String = "Glob"

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: String): FilterGlob = FilterGlob(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterGt private constructor(private val attr: String, private val value: JsonValue) :
    Filter() {
    private val f0: String = "Gt"

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: JsonValue): FilterGt = FilterGt(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterGte private constructor(private val attr: String, private val value: JsonValue) :
    Filter() {
    private val f0: String = "Gte"

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: JsonValue): FilterGte = FilterGte(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterIGlob private constructor(private val attr: String, private val value: String) :
    Filter() {
    private val f0: String = "IGlob"

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: String): FilterIGlob = FilterIGlob(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterIn private constructor(private val attr: String, private val value: JsonValue) :
    Filter() {
    private val f0: String = "In"

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: JsonValue): FilterIn = FilterIn(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterLt private constructor(private val attr: String, private val value: JsonValue) :
    Filter() {
    private val f0: String = "Lt"

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: JsonValue): FilterLt = FilterLt(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterLte private constructor(private val attr: String, private val value: JsonValue) :
    Filter() {
    private val f0: String = "Lte"

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: JsonValue): FilterLte = FilterLte(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("f0", "filter")
class FilterNot private constructor(private val filter: Filter) : Filter() {
    private val f0: String = "Not"

    companion object {
        @JvmSynthetic internal fun create(filter: Filter): FilterNot = FilterNot(filter)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterNotEq private constructor(private val attr: String, private val value: JsonValue) :
    Filter() {
    private val f0: String = "NotEq"

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: JsonValue): FilterNotEq = FilterNotEq(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterNotGlob private constructor(private val attr: String, private val value: String) :
    Filter() {
    private val f0: String = "NotGlob"

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: String): FilterNotGlob = FilterNotGlob(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterNotIGlob private constructor(private val attr: String, private val value: String) :
    Filter() {
    private val f0: String = "NotIGlob"

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: String): FilterNotIGlob =
            FilterNotIGlob(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterNotIn private constructor(private val attr: String, private val value: JsonValue) :
    Filter() {
    private val f0: String = "NotIn"

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: JsonValue): FilterNotIn = FilterNotIn(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("f0", "filters")
class FilterOr private constructor(private val filters: List<Filter>) : Filter() {
    private val f0: String = "Or"

    companion object {
        @JvmSynthetic internal fun create(filters: List<Filter>): FilterOr = FilterOr(filters)
    }
}

sealed class RankBy() {
    companion object {
        @JvmStatic
        public fun vector(attr: String, value: List<Float>): RankByVector =
            RankByVector.create(attr, value)

        @JvmStatic
        public fun attribute(attr: String, order: RankByAttributeOrder): RankByAttribute =
            RankByAttribute.create(attr, order)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "order")
class RankByAttribute
private constructor(private val attr: String, private val order: RankByAttributeOrder) : RankBy() {
    companion object {
        @JvmSynthetic
        internal fun create(attr: String, order: RankByAttributeOrder): RankByAttribute =
            RankByAttribute(attr, order)
    }
}

enum class RankByAttributeOrder {
    @JsonProperty("asc") ASC,
    @JsonProperty("desc") DESC,
}

sealed class RankByText() : RankBy() {
    companion object {
        @JvmStatic
        public fun bm25(attr: String, value: String): RankByTextBM25 =
            RankByTextBM25.create(attr, value)

        @JvmStatic
        public fun bm25Array(attr: String, value: List<String>): RankByTextBM25Array =
            RankByTextBM25Array.create(attr, value)

        @JvmStatic
        public fun sum(subqueries: List<RankByText>): RankByTextSum =
            RankByTextSum.create(subqueries)

        @JvmStatic
        public fun max(subqueries: List<RankByText>): RankByTextMax =
            RankByTextMax.create(subqueries)

        @JvmStatic
        public fun product(weight: Double, subquery: RankByText): RankByTextProduct =
            RankByTextProduct.create(weight, subquery)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class RankByTextBM25 private constructor(private val attr: String, private val value: String) :
    RankByText() {
    private val f0: String = "BM25"

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: String): RankByTextBM25 =
            RankByTextBM25(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class RankByTextBM25Array
private constructor(private val attr: String, private val value: List<String>) : RankByText() {
    private val f0: String = "BM25"

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: List<String>): RankByTextBM25Array =
            RankByTextBM25Array(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("f0", "subqueries")
class RankByTextMax private constructor(private val subqueries: List<RankByText>) : RankByText() {
    private val f0: String = "Max"

    companion object {
        @JvmSynthetic
        internal fun create(subqueries: List<RankByText>): RankByTextMax = RankByTextMax(subqueries)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("f0", "f1")
class RankByTextProduct
private constructor(
    @JsonIgnore private val weight: Double,
    @JsonIgnore private val subquery: RankByText,
) : RankByText() {
    private val f0: String = "Product"
    private val f1: List<JsonValue> = listOf(JsonValue.from(weight), JsonValue.from(subquery))

    companion object {
        @JvmSynthetic
        internal fun create(weight: Double, subquery: RankByText): RankByTextProduct =
            RankByTextProduct(weight, subquery)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("f0", "subqueries")
class RankByTextSum private constructor(private val subqueries: List<RankByText>) : RankByText() {
    private val f0: String = "Sum"

    companion object {
        @JvmSynthetic
        internal fun create(subqueries: List<RankByText>): RankByTextSum = RankByTextSum(subqueries)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class RankByVector private constructor(private val attr: String, private val value: List<Float>) :
    RankBy() {
    private val f0: String = "ANN"

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: List<Float>): RankByVector =
            RankByVector(attr, value)
    }
}

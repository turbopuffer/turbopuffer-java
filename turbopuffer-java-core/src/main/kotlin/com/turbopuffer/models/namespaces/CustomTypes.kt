// Code generated by turbopuffer-apigen. DO NOT EDIT.

package com.turbopuffer.models.namespaces

import com.fasterxml.jackson.annotation.JsonAutoDetect
import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility
import com.fasterxml.jackson.annotation.JsonFormat
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.annotation.JsonPropertyOrder
import com.fasterxml.jackson.databind.json.JsonMapper
import com.turbopuffer.core.JsonValue
import com.turbopuffer.core.jsonMapper

val jsonMapper: JsonMapper = jsonMapper()

sealed class AggregateBy() {
    companion object {
        @JvmStatic public fun count(attr: String): AggregateByCount = AggregateByCount.create(attr)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("f0", "attr")
class AggregateByCount private constructor(attr: String) : AggregateBy() {
    private val f0: String = "Count"
    private val attr: String = attr

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic internal fun create(attr: String): AggregateByCount = AggregateByCount(attr)
    }
}

sealed class Expr() {
    companion object {
        @JvmStatic public fun refNew(refNew: String): ExprRefNew = ExprRefNew.create(refNew)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonPropertyOrder("refNew")
class ExprRefNew private constructor(refNew: String) : Expr() {
    @JsonProperty("\$ref_new") private val refNew: String = refNew

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic internal fun create(refNew: String): ExprRefNew = ExprRefNew(refNew)
    }
}

sealed class Filter() {
    companion object {
        @JvmStatic public fun eq(attr: String, value: Any): FilterEq = FilterEq.create(attr, value)

        @JvmStatic
        public fun notEq(attr: String, value: Any): FilterNotEq = FilterNotEq.create(attr, value)

        @JvmStatic
        public fun `in`(attr: String, value: List<Any>): FilterIn = FilterIn.create(attr, value)

        @JvmStatic
        public fun notIn(attr: String, value: List<Any>): FilterNotIn =
            FilterNotIn.create(attr, value)

        @JvmStatic
        public fun contains(attr: String, value: Any): FilterContains =
            FilterContains.create(attr, value)

        @JvmStatic
        public fun notContains(attr: String, value: Any): FilterNotContains =
            FilterNotContains.create(attr, value)

        @JvmStatic
        public fun containsAny(attr: String, value: List<Any>): FilterContainsAny =
            FilterContainsAny.create(attr, value)

        @JvmStatic
        public fun notContainsAny(attr: String, value: List<Any>): FilterNotContainsAny =
            FilterNotContainsAny.create(attr, value)

        @JvmStatic public fun lt(attr: String, value: Any): FilterLt = FilterLt.create(attr, value)

        @JvmStatic
        public fun lte(attr: String, value: Any): FilterLte = FilterLte.create(attr, value)

        @JvmStatic public fun gt(attr: String, value: Any): FilterGt = FilterGt.create(attr, value)

        @JvmStatic
        public fun gte(attr: String, value: Any): FilterGte = FilterGte.create(attr, value)

        @JvmStatic
        public fun glob(attr: String, value: String): FilterGlob = FilterGlob.create(attr, value)

        @JvmStatic
        public fun notGlob(attr: String, value: String): FilterNotGlob =
            FilterNotGlob.create(attr, value)

        @JvmStatic
        public fun iGlob(attr: String, value: String): FilterIGlob = FilterIGlob.create(attr, value)

        @JvmStatic
        public fun notIGlob(attr: String, value: String): FilterNotIGlob =
            FilterNotIGlob.create(attr, value)

        @JvmStatic
        public fun containsAllTokens(attr: String, value: String): FilterContainsAllTokens =
            FilterContainsAllTokens.create(attr, value)

        @JvmStatic
        public fun containsAllTokens(
            attr: String,
            value: List<String>,
        ): FilterContainsAllTokensArray = FilterContainsAllTokensArray.create(attr, value)

        @JvmStatic public fun not(filter: Filter): FilterNot = FilterNot.create(filter)

        @JvmStatic
        public fun and(vararg filters: Filter): FilterAnd = FilterAnd.create(filters.asList())

        @JvmStatic
        public fun or(vararg filters: Filter): FilterOr = FilterOr.create(filters.asList())
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("f0", "filters")
class FilterAnd private constructor(filters: List<Filter>) : Filter() {
    private val f0: String = "And"
    private val filters: List<Filter> = filters

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic internal fun create(filters: List<Filter>): FilterAnd = FilterAnd(filters)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterContains private constructor(attr: String, value: Any) : Filter() {
    private val attr: String = attr
    private val f0: String = "Contains"
    private val value: JsonValue = JsonValue.from(value)

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: Any): FilterContains = FilterContains(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterContainsAllTokens private constructor(attr: String, value: String) : Filter() {
    private val attr: String = attr
    private val f0: String = "ContainsAllTokens"
    private val value: String = value

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: String): FilterContainsAllTokens =
            FilterContainsAllTokens(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterContainsAllTokensArray private constructor(attr: String, value: List<String>) :
    Filter() {
    private val attr: String = attr
    private val f0: String = "ContainsAllTokens"
    private val value: List<String> = value

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: List<String>): FilterContainsAllTokensArray =
            FilterContainsAllTokensArray(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterContainsAny private constructor(attr: String, value: List<Any>) : Filter() {
    private val attr: String = attr
    private val f0: String = "ContainsAny"
    private val value: List<Any> = value

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: List<Any>): FilterContainsAny =
            FilterContainsAny(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterEq private constructor(attr: String, value: Any) : Filter() {
    private val attr: String = attr
    private val f0: String = "Eq"
    private val value: JsonValue = JsonValue.from(value)

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: Any): FilterEq = FilterEq(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterGlob private constructor(attr: String, value: String) : Filter() {
    private val attr: String = attr
    private val f0: String = "Glob"
    private val value: String = value

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: String): FilterGlob = FilterGlob(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterGt private constructor(attr: String, value: Any) : Filter() {
    private val attr: String = attr
    private val f0: String = "Gt"
    private val value: JsonValue = JsonValue.from(value)

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: Any): FilterGt = FilterGt(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterGte private constructor(attr: String, value: Any) : Filter() {
    private val attr: String = attr
    private val f0: String = "Gte"
    private val value: JsonValue = JsonValue.from(value)

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: Any): FilterGte = FilterGte(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterIGlob private constructor(attr: String, value: String) : Filter() {
    private val attr: String = attr
    private val f0: String = "IGlob"
    private val value: String = value

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: String): FilterIGlob = FilterIGlob(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterIn private constructor(attr: String, value: List<Any>) : Filter() {
    private val attr: String = attr
    private val f0: String = "In"
    private val value: List<Any> = value

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: List<Any>): FilterIn = FilterIn(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterLt private constructor(attr: String, value: Any) : Filter() {
    private val attr: String = attr
    private val f0: String = "Lt"
    private val value: JsonValue = JsonValue.from(value)

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: Any): FilterLt = FilterLt(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterLte private constructor(attr: String, value: Any) : Filter() {
    private val attr: String = attr
    private val f0: String = "Lte"
    private val value: JsonValue = JsonValue.from(value)

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: Any): FilterLte = FilterLte(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("f0", "filter")
class FilterNot private constructor(filter: Filter) : Filter() {
    private val f0: String = "Not"
    private val filter: Filter = filter

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic internal fun create(filter: Filter): FilterNot = FilterNot(filter)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterNotContains private constructor(attr: String, value: Any) : Filter() {
    private val attr: String = attr
    private val f0: String = "NotContains"
    private val value: JsonValue = JsonValue.from(value)

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: Any): FilterNotContains =
            FilterNotContains(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterNotContainsAny private constructor(attr: String, value: List<Any>) : Filter() {
    private val attr: String = attr
    private val f0: String = "NotContainsAny"
    private val value: List<Any> = value

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: List<Any>): FilterNotContainsAny =
            FilterNotContainsAny(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterNotEq private constructor(attr: String, value: Any) : Filter() {
    private val attr: String = attr
    private val f0: String = "NotEq"
    private val value: JsonValue = JsonValue.from(value)

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: Any): FilterNotEq = FilterNotEq(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterNotGlob private constructor(attr: String, value: String) : Filter() {
    private val attr: String = attr
    private val f0: String = "NotGlob"
    private val value: String = value

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: String): FilterNotGlob = FilterNotGlob(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterNotIGlob private constructor(attr: String, value: String) : Filter() {
    private val attr: String = attr
    private val f0: String = "NotIGlob"
    private val value: String = value

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: String): FilterNotIGlob =
            FilterNotIGlob(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class FilterNotIn private constructor(attr: String, value: List<Any>) : Filter() {
    private val attr: String = attr
    private val f0: String = "NotIn"
    private val value: List<Any> = value

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: List<Any>): FilterNotIn = FilterNotIn(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("f0", "filters")
class FilterOr private constructor(filters: List<Filter>) : Filter() {
    private val f0: String = "Or"
    private val filters: List<Filter> = filters

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic internal fun create(filters: List<Filter>): FilterOr = FilterOr(filters)
    }
}

sealed class RankBy() {
    companion object {
        @JvmStatic
        public fun vector(attr: String, value: List<Float>): RankByVector =
            RankByVector.create(attr, value)

        @JvmStatic
        public fun attribute(attr: String, order: RankByAttributeOrder): RankByAttribute =
            RankByAttribute.create(attr, order)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "order")
class RankByAttribute private constructor(attr: String, order: RankByAttributeOrder) : RankBy() {
    private val attr: String = attr
    private val order: RankByAttributeOrder = order

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, order: RankByAttributeOrder): RankByAttribute =
            RankByAttribute(attr, order)
    }
}

enum class RankByAttributeOrder {
    @JsonProperty("asc") ASC,
    @JsonProperty("desc") DESC,
}

sealed class RankByText() : RankBy() {
    companion object {
        @JvmStatic
        public fun bm25(attr: String, value: String): RankByTextBM25 =
            RankByTextBM25.create(attr, value)

        @JvmStatic
        public fun bm25(attr: String, value: List<String>): RankByTextBM25Array =
            RankByTextBM25Array.create(attr, value)

        @JvmStatic
        public fun sum(vararg subqueries: RankByText): RankByTextSum =
            RankByTextSum.create(subqueries.asList())

        @JvmStatic
        public fun max(vararg subqueries: RankByText): RankByTextMax =
            RankByTextMax.create(subqueries.asList())

        @JvmStatic
        public fun product(weight: Double, subquery: RankByText): RankByTextProduct =
            RankByTextProduct.create(weight, subquery)

        @JvmStatic
        public fun product(subquery: RankByText, weight: Double): RankByTextProduct2 =
            RankByTextProduct2.create(subquery, weight)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class RankByTextBM25 private constructor(attr: String, value: String) : RankByText() {
    private val attr: String = attr
    private val f0: String = "BM25"
    private val value: String = value

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: String): RankByTextBM25 =
            RankByTextBM25(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class RankByTextBM25Array private constructor(attr: String, value: List<String>) : RankByText() {
    private val attr: String = attr
    private val f0: String = "BM25"
    private val value: List<String> = value

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: List<String>): RankByTextBM25Array =
            RankByTextBM25Array(attr, value)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("f0", "subqueries")
class RankByTextMax private constructor(subqueries: List<RankByText>) : RankByText() {
    private val f0: String = "Max"
    private val subqueries: List<RankByText> = subqueries

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(subqueries: List<RankByText>): RankByTextMax = RankByTextMax(subqueries)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("f0", "f1")
class RankByTextProduct private constructor(weight: Double, subquery: RankByText) : RankByText() {
    private val f0: String = "Product"
    private val f1: List<JsonValue> = listOf(JsonValue.from(weight), JsonValue.from(subquery))

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(weight: Double, subquery: RankByText): RankByTextProduct =
            RankByTextProduct(weight, subquery)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("f0", "f1")
class RankByTextProduct2 private constructor(subquery: RankByText, weight: Double) : RankByText() {
    private val f0: String = "Product"
    private val f1: List<JsonValue> = listOf(JsonValue.from(subquery), JsonValue.from(weight))

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(subquery: RankByText, weight: Double): RankByTextProduct2 =
            RankByTextProduct2(subquery, weight)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("f0", "subqueries")
class RankByTextSum private constructor(subqueries: List<RankByText>) : RankByText() {
    private val f0: String = "Sum"
    private val subqueries: List<RankByText> = subqueries

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(subqueries: List<RankByText>): RankByTextSum = RankByTextSum(subqueries)
    }
}

@JsonAutoDetect(fieldVisibility = Visibility.ANY)
@JsonFormat(shape = JsonFormat.Shape.ARRAY)
@JsonPropertyOrder("attr", "f0", "value")
class RankByVector private constructor(attr: String, value: List<Float>) : RankBy() {
    private val attr: String = attr
    private val f0: String = "ANN"
    private val value: List<Float> = value

    override fun toString(): String {
        return jsonMapper.writeValueAsString(this)
    }

    companion object {
        @JvmSynthetic
        internal fun create(attr: String, value: List<Float>): RankByVector =
            RankByVector(attr, value)
    }
}
